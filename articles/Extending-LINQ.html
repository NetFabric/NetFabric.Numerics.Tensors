<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Extending LINQ | NetFabric.Numerics </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Extending LINQ | NetFabric.Numerics ">
      
      
      <link rel="icon" href="../images/Logo.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/NetFabric/NetFabric.Numerics.Tensors/blob/main/docs/articles/Extending-LINQ.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

      <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-E372L91FWS"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-E372L91FWS');
      </script>
  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/Logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="extending-linq">Extending LINQ</h1>

<p>LINQ, which stands for Language-Integrated Query, offers a versatile set of methods for processing collections efficiently. While LINQ includes optimizations for specific scenarios, as a library developer, it's beneficial to extend LINQ methods with overloads to support new numeric types. This ensures that your types are processed more efficiently within LINQ operations.</p>
<p>For instance, let's consider a scenario where your library implements a 2D vector based on generic math, as shown below (simplified for this example):</p>
<pre><code class="lang-csharp">public readonly record struct MyVector2&lt;T&gt;(T X, T Y)
    : IAdditiveIdentity&lt;MyVector2&lt;T&gt;, MyVector2&lt;T&gt;&gt;
    , IAdditionOperators&lt;MyVector2&lt;T&gt;, MyVector2&lt;T&gt;, MyVector2&lt;T&gt;&gt;
    where T : struct, INumber&lt;T&gt;
{
    public MyVector2(ValueTuple&lt;T, T&gt; tuple)
        : this(tuple.Item1, tuple.Item2)
    { }

    public static MyVector2&lt;T&gt; AdditiveIdentity
        =&gt; new(T.AdditiveIdentity, T.AdditiveIdentity);

    public static MyVector2&lt;T&gt; operator +(MyVector2&lt;T&gt; left, MyVector2&lt;T&gt; right)
        =&gt; new(left.X + right.X, left.Y + right.Y);
}
</code></pre>
<p>LINQ provides a <code>Sum()</code> method for specific native numeric types or types that can be converted to them using a transform lambda expression. However, it's advantageous to provide a dedicated <code>Sum()</code> method for custom types. We can start by implementing the following:</p>
<pre><code class="lang-csharp">public static class MyVector2
{
    public static MyVector2&lt;T&gt; Sum&lt;T&gt;(this IEnumerable&lt;MyVector2&lt;T&gt;&gt; source)
        where T : struct, INumber&lt;T&gt;
    {
        var sum = MyVector2&lt;T&gt;.AdditiveIdentity;
        foreach (var value in source)
            sum += value;
        return sum;
    }
}
</code></pre>
<p>Like any other method in the LINQ library, this is an extension method for the <code>IEnumerable&lt;T&gt;</code> interface, specifically tailored for <code>MyVector2&lt;T&gt;</code>. The compiler automatically selects the appropriate overload based on the extended type.</p>
<p>However, if the source collection is an array or a span, the optimizations provided by <code>NetFabric.Numerics.Tensors</code> are not utilized. To address this, we need to provide additional overloads to cover all scenarios:</p>
<pre><code class="lang-csharp">public static class MyVector2
{
    public static MyVector2&lt;T&gt; Sum&lt;T&gt;(this IEnumerable&lt;MyVector2&lt;T&gt;&gt; source)
        where T : struct, INumber&lt;T&gt;
    {
        if (source.TryGetSpan(out var span))
            return Sum(span);

        var sum = MyVector2&lt;T&gt;.AdditiveIdentity;
        foreach (var value in source)
            sum += value;
        return sum;
    }

    public static MyVector2&lt;T&gt; Sum&lt;T&gt;(this List&lt;MyVector2&lt;T&gt;&gt; source)
        where T : struct, INumber&lt;T&gt;
        =&gt; Sum(CollectionsMarshal.AsSpan(source));

    public static MyVector2&lt;T&gt; Sum&lt;T&gt;(this MyVector2&lt;T&gt;[] source)
        where T : struct, INumber&lt;T&gt;
        =&gt; Sum(source.AsSpan());

    public static MyVector2&lt;T&gt; Sum&lt;T&gt;(this Span&lt;MyVector2&lt;T&gt;&gt; source)
        where T : struct, INumber&lt;T&gt;
        =&gt; Sum((ReadOnlySpan&lt;MyVector2&lt;T&gt;&gt;)source);

    public static MyVector2&lt;T&gt; Sum&lt;T&gt;(this ReadOnlySpan&lt;MyVector2&lt;T&gt;&gt; source)
        where T : struct, INumber&lt;T&gt;
        =&gt; TensorOperations.Sum(source);
}
</code></pre>
<p>Note that the method taking a <code>IEnumerable&lt;MyVector2&lt;T&gt;&gt;</code> parameter checks if the source collection can be converted to a span using the <code>TryGetSpan()</code> method provided by <a href="https://www.nuget.org/packages/NetFabric">the <code>NetFabric</code> NuGet package</a>. If so, it calls the overload accepting a <code>ReadOnlySpan&lt;MyVector2&lt;T&gt;&gt;</code>, which in turn invokes the optimized <code>TensorOperations.Sum()</code>.</p>
<p>The overload for <code>List&lt;MyVector2&lt;T&gt;&gt;</code> uses <code>CollectionsMarshal.AsSpan()</code> to obtain its internal span, as explained in the <code>Working with List&lt;T&gt;</code> section.</p>
<p>While explicit method calls automatically convert types <code>T[]</code> and <code>Span&lt;T&gt;</code> to <code>ReadOnlySpan&lt;T&gt;</code>, this conversion doesn't occur when calling extension methods. Therefore, providing all these overloads ensures users don't need to perform explicit conversions.</p>
<p>By offering these overloads, the compiler can directly invoke the most appropriate one, skipping type checks conducted in the initial overload and adds support for spans, which LINQ doesn't inherently support as these don't implement <code>IEnumerable&lt;T&gt;</code>.</p>
<p>Offering these overloads ensures that users accustomed to employing LINQ will consistently achieve optimal performance regardless of the scenario.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/NetFabric/NetFabric.Numerics.Tensors/blob/main/docs/articles/Extending-LINQ.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (c) 2023-2024 Antão Almada
        </div>
      </div>
    </footer>
  </body>
</html>
