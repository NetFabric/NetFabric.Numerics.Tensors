<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Extending the Library Functionality | NetFabric.Numerics </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Extending the Library Functionality | NetFabric.Numerics ">
      
      
      <link rel="icon" href="../images/Logo.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/NetFabric/NetFabric.Numerics.Tensors/blob/main/docs/articles/Extending-the-library.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

      <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-E372L91FWS"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-E372L91FWS');
      </script>
  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/Logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="extending-the-library-functionality">Extending the Library Functionality</h1>

<p>While <code>NetFabric.Numerics.Tensors</code> offers a variety of predefined operations, their combination may not be optimal, leading to multiple iterations over the sources. Anticipating and implementing all potential combinations can pose a significant challenge. To address this concern, <code>NetFabric.Numerics.Tensors</code> facilitates the implementation of custom operators and the composition of operators. These capabilities empower users to define specific operations while still harnessing the high-performance reusable iteration code.</p>
<h2 id="harnessing-pre-defined-operations">Harnessing Pre-defined Operations</h2>
<p>Before delving into crafting custom operations, assess whether you can make use of any of the predefined operations. For example, the conversion of degrees into radians adheres to the formula <code>(value * PI) / 180.0</code>. The <code>MultiplyDivide</code> operation proves handy here, as it multiplies the first two parameters and divides by the third. As an example, the predefined <code>DegreesToRadians()</code> operation is implemented as follows:</p>
<pre><code class="lang-csharp">public static void DegreesToRadians&lt;T&gt;(ReadOnlySpan&lt;T&gt; left, Span&lt;T&gt; destination)
    where T : struct, INumberBase&lt;T&gt;, IFloatingPointConstants&lt;T&gt;
    =&gt; MultiplyDivide(left, T.Pi, T.CreateChecked(180), destination);
</code></pre>
<p>Consider evaluating the potential utilization of combinations of predefined operators with the <code>Apply()</code> or <code>Aggregate()</code> methods, as elaborated below. The predefined operators are all defined in the <code>NetFabric.Numerics.Tensors.Operators</code> namespace.</p>
<h2 id="custom-operation-definitions">Custom Operation Definitions</h2>
<p>All methods enabling operator functionality are housed within the <code>Tensor</code> static class. Within this class, there are two primary categories of methods: <code>Apply</code> and <code>Aggregate</code>. The <code>Apply</code> methods are designed to execute operations on one, two, or three source <code>ReadOnlySpan&lt;T&gt;</code>, with the results stored in the destination <code>Span&lt;T&gt;</code>. Conversely, the <code>Aggregate</code> methods aim to condense a source span of data into either a single value or a tuple of values.</p>
<h3 id="apply">Apply</h3>
<p>The <code>Apply()</code> method simplifies the execution of operations involving one, two, or three source <code>ReadOnlySpan&lt;T&gt;</code>, with the results stored in the destination <code>Span&lt;T&gt;</code>. It supports in-place operations if the destination matches one of the sources.</p>
<p><code>Apply()</code> provides overloads that accept a scalar value or a tuple in place of the second or third source spans, when applicable. These overloads save the need to allocate a new span for the second or third source when the operation is performed on a single scalar value or a tuple of values.</p>
<p>This method requires several generics parameters. The initial parameters specify the type of elements in the source span, with the count varying depending on the operator used. Following this is the type of elements in the destination span, and finally, the operator to be applied. In cases where the type remains consistent across all spans, an alternative overload with fewer generics parameters is available for the <code>Apply()</code> method.</p>
<p>Operators must adhere to one of the following interfaces:</p>
<pre><code class="lang-csharp">public interface IUnaryOperator&lt;T, TResult&gt;
    : IOperator
    where T : struct
    where TResult : struct
{
    static abstract TResult Invoke(T x);
    static abstract Vector&lt;TResult&gt; Invoke(ref readonly Vector&lt;T&gt; x);
}

public interface IBinaryOperator&lt;T1, T2, TResult&gt;
    : IOperator
    where T1 : struct
    where T2 : struct
    where TResult : struct
{
    static abstract TResult Invoke(T1 x, T2 y);
    static abstract Vector&lt;TResult&gt; Invoke(ref readonly Vector&lt;T1&gt; x, ref readonly Vector&lt;T2&gt; y);
}

public interface IBinaryScalarOperator&lt;T1, T2, TResult&gt;
    : IOperator
    where T1 : struct
    where TResult : struct
{
    static abstract TResult Invoke(T1 x, T2 y);
    static abstract Vector&lt;TResult&gt; Invoke(ref readonly Vector&lt;T1&gt; x, T2 y);
}

public interface ITernaryOperator&lt;T1, T2, T3, TResult&gt;
    : IOperator
    where T1 : struct
    where T2 : struct
    where T3 : struct
    where TResult : struct
{
    static abstract TResult Invoke(T1 x, T2 y, T3 z);
    static abstract Vector&lt;TResult&gt; Invoke(ref readonly Vector&lt;T1&gt; x, ref readonly Vector&lt;T2&gt; y, ref readonly Vector&lt;T3&gt; z);
}
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> It's essential to note that these interfaces make use of <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members">static virtual members</a>, a feature introduced in .NET 7. No instance of the operator is required to use the methods, and operators are pure, devoid of internal state.</p>
</blockquote>
<p>Each operator is required to implement two <code>Invoke</code> methods, defining the operation between elements of type <code>T</code> or vectors of type <code>Vector&lt;T&gt;</code>. The second method is utilized when both the operator and the hardware support vectorization. Conversely, the first method is employed for every element that is not handled by vectorization.</p>
<p>Each interface specifies a varying number of operator parameters. The utilization of distinct generic types for each parameter ensures the maximum generalization of the operators.</p>
<p>Consider the square operator as an example, which functions as a unary operator designed to operate on a single source. It implements the <code>IUnaryOperator&lt;T&gt;</code> interface. The generic type <code>T</code> is restricted to <code>struct</code> and must implement <code>IMultiplyOperators&lt;T, T, T</code>, indicating that only value types with the <code>*</code> operator implemented are suitable. The <code>Invoke</code> methods straightforwardly execute the square operation for either a single <code>T</code> value or a <code>Vector&lt;T&gt;</code> of values:</p>
<pre><code class="lang-csharp">public readonly struct SquareOperator&lt;T&gt;
    : IUnaryOperator&lt;T&gt;
    where T : struct, IMultiplyOperators&lt;T, T, T&gt;
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Invoke(T x)
        =&gt; x * x;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector&lt;T&gt; Invoke(ref readonly Vector&lt;T&gt; x)
        =&gt; x * x;
}
</code></pre>
<p>Similarly, consider an addition operator, a binary operator that works on two sources, the addends. It implements the <code>IBinaryOperator&lt;T, T, T&gt;</code> interface. The generic type <code>T</code> is confined to <code>struct</code> and must implement <code>IAdditionOperators&lt;T, T, T&gt;</code>, indicating that only value types with the <code>+</code> operator implemented are eligible. The <code>Invoke()</code> methods straightforwardly perform the addition operation for either a single <code>T</code> value or a <code>Vector&lt;T&gt;</code> of values:</p>
<pre><code class="lang-csharp">readonly struct AddOperator&lt;T&gt;
    : IBinaryOperator&lt;T, T, T&gt;
    where T : struct, IAdditionOperators&lt;T, T, T&gt;
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Invoke(T x, T y)
        =&gt; x + y;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector&lt;T&gt; Invoke(ref readonly Vector&lt;T&gt; x, ref readonly Vector&lt;T&gt; y)
        =&gt; x + y;
}
</code></pre>
<p>The shift left operator (<code>&lt;&lt;</code>) is a binary operator that operates on a source value and a count. Typically, in this scenario, all elements in the span are shifted by the same amount. Actually, <code>Vector&lt;T&gt;</code> only supports this particular scenario. Hence, the shift left operator is implemented as a binary scalar operator, where the second parameter is a scalar value instead of a <code>Vector&lt;T&gt;</code>.</p>
<p>The shift left operation is supported by <code>Vector&lt;T&gt;</code> only for signed and unsigned integer primitives. Below is the specific implementation for the <code>sbyte</code> type. It implements the <code>IBinaryScalarOperator&lt;T, T, T&gt;</code> interface:</p>
<pre><code class="lang-csharp">readonly struct ShiftLeftSByteOperator
    : IBinaryScalarOperator&lt;sbyte, int, sbyte&gt;
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static sbyte Invoke(sbyte value, int count)
        =&gt; (sbyte)(value &lt;&lt; count);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector&lt;sbyte&gt; Invoke(ref readonly Vector&lt;sbyte&gt; value, int count)
        =&gt; Vector.ShiftLeft(value, count);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> When multiple scalars are needed, a value-typed tuple can serve as the parameter.</p>
</blockquote>
<p>Furthermore, consider an operator calculating the addition followed by multiplication of values. This is a ternary operator that handles three sources: the two addends plus the multiplier. It implements the <code>ITernaryOperator&lt;T, T, T, T&gt;</code> interface. The generic type <code>T</code> is constrained to <code>struct</code>, <code>IAdditionOperators&lt;T, T, T&gt;</code>, and <code>IMultiplyOperators&lt;T, T, T&gt;</code>, indicating that only value types with the <code>+</code> and <code>*</code> operators implemented are applicable. The <code>Invoke</code> methods straightforwardly perform the addition operation followed by multiplication for either a single <code>T</code> value or a <code>Vector&lt;T&gt;</code> of values:</p>
<pre><code class="lang-csharp">readonly struct AddMultiplyOperator&lt;T&gt;
    : ITernaryOperator&lt;T, T, T, T&gt;
    where T : struct, IAdditionOperators&lt;T, T, T&gt;, IMultiplyOperators&lt;T, T, T&gt;
{
    public static T Invoke(T x, T y, T z)
        =&gt; (x + y) * z;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector&lt;T&gt; Invoke(ref readonly Vector&lt;T&gt; x, ref readonly Vector&lt;T&gt; y, ref readonly Vector&lt;T&gt; z)
        =&gt; (x + y) * z;
}
</code></pre>
<p>For an operation akin to <code>Add</code>, the library provides all the following overrides so that the user can choose the most suitable overload based on their requirements. It can take a vector, single value or a tuple in place of the second or third source spans:</p>
<pre><code class="lang-csharp">public static void Add&lt;T&gt;(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination)
    where T : struct, IAdditionOperators&lt;T, T, T&gt;
    =&gt; Apply&lt;T, AddOperator&lt;T&gt;&gt;(x, y, destination);

public static void Add&lt;T&gt;(ReadOnlySpan&lt;T&gt; x, ValueTuple&lt;T, T&gt; y, Span&lt;T&gt; destination)
    where T : struct, IAdditionOperators&lt;T, T, T&gt;
    =&gt; Apply&lt;T, AddOperator&lt;T&gt;&gt;(x, y, destination);

public static void Add&lt;T&gt;(ReadOnlySpan&lt;T&gt; x, ValueTuple&lt;T, T, T&gt; y, Span&lt;T&gt; destination)
    where T : struct, IAdditionOperators&lt;T, T, T&gt;
    =&gt; Apply&lt;T, AddOperator&lt;T&gt;&gt;(x, y, destination);

public static void Add&lt;T&gt;(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination)
    where T : struct, IAdditionOperators&lt;T, T, T&gt;
    =&gt; Apply&lt;T, AddOperator&lt;T&gt;&gt;(x, y, destination);
</code></pre>
<p>These overloads that take a tuple as a parameter prove especially valuable when dealing with multi-dimensional data. For further details, refer to the section on &quot;Working with Tensors for Structured Data&quot;.</p>
<h3 id="apply2">Apply2</h3>
<p>The <code>Apply2()</code> method simplifies the execution of two distinct operations within a single iteration of the source, storing the results in two separate destination <code>Span&lt;T&gt;</code> instances.</p>
<p>This method requires five generics parameters. The first specifies the type of elements within the source span, while the second and third specify the types of elements within the destination spans. The fourth and fifth parameters specify the operators to be applied. For scenarios where the type remains consistent across all spans, an alternative overload with fewer generics parameters is available for the <code>Apply2()</code> method.</p>
<p>For instance, let's consider the <code>SinCos()</code> method, which computes the sine and cosine of an angle simultaneously. This library offers two overloads for the <code>SinCos()</code> method. The first utilizes <code>Apply()</code> to return a span containing tuples of sine and cosine results, while the second employs <code>Apply2()</code> to return the results separately in designated spans.</p>
<pre><code class="lang-csharp">public static void SinCos&lt;T&gt;(ReadOnlySpan&lt;T&gt; left, Span&lt;(T Sin, T Cos)&gt; destination)
    where T : struct, ITrigonometricFunctions&lt;T&gt;
    =&gt; Apply&lt;T, (T Sin, T Cos), SinCosOperator&lt;T&gt;&gt;(left, destination);

public static void SinCos&lt;T&gt;(ReadOnlySpan&lt;T&gt; left, Span&lt;T&gt; sinDestination, Span&lt;T&gt; cosDestination)
    where T : struct, ITrigonometricFunctions&lt;T&gt;
    =&gt; Apply2&lt;T, SinOperator&lt;T&gt;, CosOperator&lt;T&gt;&gt;(left, sinDestination, cosDestination);
</code></pre>
<p>With the operators implemented as follows:</p>
<pre><code class="lang-csharp">readonly struct SinOperator&lt;T&gt;
    : IUnaryOperator&lt;T, T&gt;
    where T : struct, ITrigonometricFunctions&lt;T&gt;
{
    public static bool IsVectorizable
        =&gt; false;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Invoke(T x)
        =&gt; T.Sin(x);

    public static Vector&lt;T&gt; Invoke(ref readonly Vector&lt;T&gt; x)
        =&gt; Throw.InvalidOperationException&lt;Vector&lt;T&gt;&gt;();
}

readonly struct CosOperator&lt;T&gt;
    : IUnaryOperator&lt;T, T&gt;
    where T : struct, ITrigonometricFunctions&lt;T&gt;
{
    public static bool IsVectorizable
        =&gt; false;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Invoke(T x)
        =&gt; T.Cos(x);

    public static Vector&lt;T&gt; Invoke(ref readonly Vector&lt;T&gt; x)
        =&gt; Throw.InvalidOperationException&lt;Vector&lt;T&gt;&gt;();
}

readonly struct SinCosOperator&lt;T&gt;
    : IUnaryOperator&lt;T, (T Sin, T Cos)&gt;
    where T : struct, ITrigonometricFunctions&lt;T&gt;
{
    public static bool IsVectorizable
        =&gt; false;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T Sin, T Cos) Invoke(T x)
        =&gt; T.SinCos(x);

    public static Vector&lt;(T Sin, T Cos)&gt; Invoke(ref readonly Vector&lt;T&gt; x)
        =&gt; Throw.InvalidOperationException&lt;Vector&lt;(T Sin, T Cos)&gt;&gt;();
}

</code></pre>
<p>The user can choose the most suitable overload based on their requirements.</p>
<h3 id="aggregate">Aggregate</h3>
<p>The <code>Aggregate()</code> method is a powerful tool for consolidating a source span of data into either a single value or a tuple of values. It operates using two essential operators: one for transforming the source elements and another for aggregating the transformed elements. This method adheres to the IEEE 754 standard for floating-point arithmetic; if any element's transformation results in <code>NaN</code>, it returns <code>NaN</code>.</p>
<p>It's essential to note that the transform operator must implement either the <code>IUnaryOperator&lt;T, TResult&gt;</code> or <code>IBinaryOperator&lt;T1, T2, TResult&gt;</code> interface, while the aggregation operator must implement the <code>IAggregationOperator&lt;TResult, TResult&gt;</code> interface.</p>
<pre><code class="lang-csharp">public interface IAggregationOperator&lt;T, TResult&gt;
    : IBinaryOperator&lt;TResult, T, TResult&gt;
    where T : struct
    where TResult : struct
{
    static virtual TResult Seed
        =&gt; Throw.NotSupportedException&lt;TResult&gt;();

    static abstract TResult Invoke(TResult x, TResult y);

    static abstract TResult Invoke(TResult x, ref readonly Vector&lt;TResult&gt; y);
}
</code></pre>
<p>Each operator must provide a property returning the seed value, initializing the aggregation process. Additionally, operators must implement the required <code>Invoke</code> methods by the <code>IBinaryOperator&lt;T1, T2, TResult&gt;</code> interface, along with two extra <code>Invoke</code> methods that aggregates the final result. On the last <code>Invoke</code> it's guaranteed that the parameters will not contain <code>NaN</code>.</p>
<p>For example, consider an operation calculating the sum of all elements in the source. It employs the following aggregation operator:</p>
<pre><code class="lang-csharp">readonly struct SumOperator&lt;T&gt;
    : IAggregationOperator&lt;T, T&gt;
    where T : struct, IAdditiveIdentity&lt;T, T&gt;, IAdditionOperators&lt;T, T, T&gt;
{
    public static T Seed
        =&gt; T.AdditiveIdentity;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Invoke(T x, T y)
        =&gt; x + y;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector&lt;T&gt; Invoke(ref readonly Vector&lt;T&gt; x, ref readonly Vector&lt;T&gt; y)
        =&gt; x + y;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Invoke(T x, ref readonly Vector&lt;T&gt; y)
        =&gt; x + Vector.Sum(y);
}
</code></pre>
<p>This operator adheres to the <code>IAggregationOperator&lt;T, T&gt;</code> interface. The generic type <code>T</code> is constrained to <code>struct</code>, <code>IAdditiveIdentity&lt;T, T&gt;</code>, and <code>IAdditionOperators&lt;T, T, T&gt;</code>, indicating that only value types with both the additive identity and the <code>+</code> operator implemented are suitable. The <code>Seed</code> initializes the sum using the additive identity. The two first <code>Invoke()</code> methods straightforwardly perform the addition operation for either a single <code>T</code> value or a <code>Vector&lt;T&gt;</code> of values. The last <code>Invoke</code>, sums the aggregated value to the sum of the elements in the aggregated vector.</p>
<p>The <code>Sum()</code> operation can be utilized as follows:</p>
<pre><code class="lang-csharp">public static T Sum&lt;T&gt;(ReadOnlySpan&lt;T&gt; source)
    where T : struct, INumberBase&lt;T&gt;
    =&gt; Tensor.Aggregate&lt;T, SumOperator&lt;T&gt;&gt;(source);
</code></pre>
<p>Here, the generic type <code>T</code> is restricted to <code>INumberBase&lt;T&gt;</code> as the <code>Aggregate()</code> method requires the method <code>T.IsNaN()</code> for checking if any transformation results in <code>NaN</code>.</p>
<p>A transform operator can be applied to transform the source elements before aggregation. For instance, consider an operation calculating the sum of the squares of all elements in the source. This operation can be employed to compute the square of the length of any n-dimensional vector:</p>
<pre><code class="lang-csharp">public static T SumOfSquares&lt;T&gt;(ReadOnlySpan&lt;T&gt; source)
    where T : struct, IMultiplyOperators&lt;T, T, T&gt;, IAdditionOperators&lt;T, T, T&gt;, IAdditiveIdentity&lt;T, T&gt;
    =&gt; Tensor.Aggregate&lt;T, SquareOperator&lt;T&gt;, SumOperator&lt;T&gt;&gt;(source);
</code></pre>
<p>Here, the <code>SquareOperator&lt;T&gt;</code> and <code>SumOperator&lt;T&gt;</code> operators are utilized. The <code>SquareOperator&lt;T&gt;</code> operator is a unary operator that squares the source elements, while the <code>SumOperator&lt;T&gt;</code> operator aggregates the transformed elements.</p>
<p>The transform operator can also take two parameters, as shown in the <code>ProductOfAdditions()</code> operation, which computes the sum of the products of corresponding elements in two sources:</p>
<pre><code class="lang-csharp">public static T? ProductOfAdditions&lt;T&gt;(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y)
    where T : struct, IMultiplicativeIdentity&lt;T, T&gt;, IAdditionOperators&lt;T, T, T&gt;, IMultiplyOperators&lt;T, T, T&gt;
    =&gt; x.IsEmpty
        ? null
        : Tensor.Aggregate&lt;T, AddOperator&lt;T&gt;, ProductOperator&lt;T&gt;&gt;(x, y);
</code></pre>
<p>The <code>Aggregate()</code> method also provides overloads supporting different types for the source, transformed, and return values.</p>
<p>Additional variants of the <code>Aggregate()</code> method are available: <code>Aggregate2D()</code>, <code>Aggregate3D()</code>, and <code>Aggregate4D()</code>. These specialized methods are tailored to aggregate the source span into tuples of two, three, or four values, respectively, which is particularly useful for multi-dimensional data. For further details, refer to the &quot;Working with Tensors for Structured Data&quot; section.</p>
<h3 id="indexofaggregate">IndexOfAggregate</h3>
<p>The <code>IndexOfAggregate()</code> method functions similarly to <code>Aggregate()</code> but returns the index of the first element matching the value returned by <code>Aggregate()</code>.</p>
<p>For instance, the <code>IndexOfMax()</code> aggregation retrieves the index of the maximum value in the source span:</p>
<pre><code class="lang-csharp">public static int IndexOfMax&lt;T&gt;(ReadOnlySpan&lt;T&gt; source)
    where T : struct, INumber&lt;T&gt;, IMinMaxValue&lt;T&gt;
    =&gt; Tensor.IndexOfAggregate&lt;T, MaxAggregationOperator&lt;T&gt;&gt;(source);
</code></pre>
<p>The <code>IndexOfAggregate()</code> method can use a transform operator accepting one or two parameters. Consider its application in the <code>IndexOfMaxSum()</code> aggregation operation, determining the index of the first element matching the maximum sum of corresponding elements in two sources:</p>
<pre><code class="lang-csharp">public static int IndexOfMaxSum&lt;T&gt;(ReadOnlySpan&lt;T&gt; left, ReadOnlySpan&lt;T&gt; right)
    where T : struct, INumber&lt;T&gt;, IMinMaxValue&lt;T&gt;
    =&gt; Tensor.IndexOfAggregate&lt;T, SumOperator&lt;T&gt;, MaxAggregationOperator&lt;T&gt;&gt;(left, right);
</code></pre>
<p>Here, two operators are specified as generic parameters. The first operator transforms the source elements, while the second operator aggregates the transformed elements.</p>
<h3 id="aggregate2">Aggregate2</h3>
<p>The <code>Aggregate2()</code> method simplifies the execution of two distinct operations within a single iteration of the source, returning the results in a tuple.</p>
<p>This method requires three generic parameters. The first determines the type of elements within the source span, while the second and third parameters specify the operators to apply.</p>
<p>For instance, let's examine the <code>MinMax()</code> method, which calculates both the minimum and maximum values in a span simultaneously:</p>
<pre><code class="lang-csharp">public static (T Min, T Max) MinMax&lt;T&gt;(ReadOnlySpan&lt;T&gt; source)
    where T : struct, INumber&lt;T&gt;, IMinMaxValue&lt;T&gt;
    =&gt; Tensor.Aggregate2&lt;T, MinNumberAggregationOperator&lt;T&gt;, MaxNumberAggregationOperator&lt;T&gt;&gt;(source);
</code></pre>
<h3 id="aggregatenumber">AggregateNumber</h3>
<p>The <code>AggregateNumber</code> method functions akin to the <code>Aggregate()</code> method, but it omits propagating <code>NaN</code> values if encountered. This alternative implementation exhibits better performance and is suitable when <code>NaN</code> values are guaranteed not to occur after the source span elements are transformed.</p>
<p>For instance, let's examine the implementation of the <code>SumNumber()</code> aggregation operation:</p>
<pre><code class="lang-csharp">public static T SumNumber&lt;T&gt;(ReadOnlySpan&lt;T&gt; source)
    where T : struct, IAdditionOperators&lt;T, T, T&gt;, IAdditiveIdentity&lt;T, T&gt;
    =&gt; Tensor.AggregateNumber&lt;T, SumOperator&lt;T&gt;&gt;(source);
</code></pre>
<p>This behaves similarly to <code>Sum()</code> but without propagating <code>NaN</code> values. <strong>This principle applies to all methods suffixed with <code>Number</code> in this library.</strong></p>
<p>Further variants of the <code>AggregateNumber()</code> method exist: <code>AggregateNumber2D()</code>, <code>AggregateNumber3D()</code>, and <code>AggregateNumber4D()</code>.</p>
<h3 id="first-method">First Method</h3>
<p>The <code>First()</code> method retrieves the first element in the span that matches a specified predicate. It returns a nullable type, where <code>null</code> indicates that no item satisfying the predicate was found.</p>
<p>The predicate must conform to one of the following interfaces, where <code>TResult</code> is specified as a <code>bool</code>:</p>
<pre><code class="lang-csharp">public interface IUnaryToScalarOperator&lt;T, TResult&gt;
    : IOperator
    where T : struct
{
    static abstract TResult Invoke(T x);
    static abstract TResult Invoke(ref readonly Vector&lt;T&gt; x);
}

public interface IBinaryToScalarOperator&lt;T1, T2, TResult&gt;
    : IOperator
    where T1 : struct
    where T2 : struct
{
    static abstract TResult Invoke(T1 x, T2 y);
    static abstract TResult Invoke(ref readonly Vector&lt;T1&gt; x, ref readonly Vector&lt;T2&gt; y);
}

public interface ITernaryToScalarOperator&lt;T1, T2, T3, TResult&gt;
    : IOperator
    where T1 : struct
    where T2 : struct
    where T3 : struct
{
    static abstract TResult Invoke(T1 x, T2 y, T3 z);
    static abstract TResult Invoke(ref readonly Vector&lt;T1&gt; x, ref readonly Vector&lt;T2&gt; y, ref readonly Vector&lt;T3&gt; z);
}
</code></pre>
<p>For example, to find the element greater than or equal to a specified value, the library provides the following vectorizable operator:</p>
<pre><code class="lang-csharp">public readonly struct GreaterThanOrEqualAnyOperator&lt;T&gt;
    : IBinaryToScalarOperator&lt;T, T, bool&gt;
    where T : struct, IComparisonOperators&lt;T, T, bool&gt;
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Invoke(T x, T y)
        =&gt; x &gt;= y;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Invoke(ref readonly Vector&lt;T&gt; x, ref readonly Vector&lt;T&gt; y)
        =&gt; Vector.GreaterThanOrEqualAny(x, y);
}
</code></pre>
<p>Then, you can employ the defined operator for the following operation:</p>
<pre><code class="lang-csharp">public static T? FirstGreaterThanOrEqual&lt;T&gt;(ReadOnlySpan&lt;T&gt; source, T value)
    where T : struct, IComparisonOperators&lt;T, T, bool&gt;
    =&gt; Tensor.First&lt;T, GreaterThanOrEqualAnyOperator&lt;T&gt;&gt;(source, value);
</code></pre>
<p>This approach ensures efficient retrieval of the first matching element.</p>
<h3 id="indexoffirst-method">IndexOfFirst Method</h3>
<p>The method <code>IndexOfFirst()</code>, works similarly to <code>First()</code>, but returning the first element in the span that adheres to a specified predicate operator. Returns <code>-1</code> if no item satisfying the predicate is found.</p>
<p>For instance, to obtain the index of the first element greater than or equal to a specified scalar value, this library provides the following operation:</p>
<pre><code class="lang-csharp">public static int IndexOfFirstGreaterThanOrEqual&lt;T&gt;(ReadOnlySpan&lt;T&gt; source, T value)
    where T : struct, IComparisonOperators&lt;T, T, bool&gt;
    =&gt; Tensor.IndexOfFirst&lt;T, GreaterThanOrEqualAnyOperator&lt;T&gt;&gt;(source, value);
</code></pre>
<p>It uses exactly the same <code>GreaterThanOrEqualAnyOperator</code> operator as in the previous example.</p>
<h2 id="operators-unsuitable-for-vectorization">Operators Unsuitable for Vectorization</h2>
<p>It's important to mention that certain operators cannot be vectorized when using <code>Vector&lt;T&gt;</code>. While this library can still enhance processing performance through alternative optimizations, vectorization must be disabled for these specific operations.</p>
<p>All operator interfaces inherit from the following interface:</p>
<pre><code class="lang-csharp">public interface IOperator
{
    static virtual bool IsVectorizable
        =&gt; true;
}
</code></pre>
<p>This signifies that all operator interfaces include a boolean property indicating whether the operation is vectorizable. By default, the property returns <code>true</code>, making overloading unnecessary unless explicitly intending to return <code>false</code>.</p>
<p>Consider the left shift operation (<code>&lt;&lt;</code>) as an example. While <code>Vector&lt;T&gt;</code> supports it only for signed and unsigned integer primitives, any type implementing <code>IShiftOperators&lt;TSelf, TOther, TResult&gt;</code> can support left shift, including third-party-developed types. To cover all scenarios, a generic non-vectorizable operator can be implemented, alongside specific operators for each vectorizable type. The following example illustrates this approach, focusing on the <code>sbyte</code> type:</p>
<pre><code class="lang-csharp">readonly struct ShiftLeftOperator&lt;T, TResult&gt;
    : IBinaryScalar&lt;T, int, TResult&gt;
    where T : struct, IShiftOperators&lt;T, int, TResult&gt;
    where TResult : struct
{
    public static bool IsVectorizable
        =&gt; false;

    public static TResult Invoke(T value, int count)
        =&gt; value &lt;&lt; count;

    public static Vector&lt;TResult&gt; Invoke(ref readonly Vector&lt;T&gt; value, int count)
        =&gt; Throw.NotSupportedException&lt;Vector&lt;TResult&gt;&gt;();
}

readonly struct ShiftLeftSByteOperator
    : IBinaryScalar&lt;sbyte, int, sbyte&gt;
{
    public static sbyte Invoke(sbyte value, int count)
        =&gt; (sbyte)(value &lt;&lt; count);

    public static Vector&lt;sbyte&gt; Invoke(ref readonly Vector&lt;sbyte&gt; value, int count)
        =&gt; Vector.ShiftLeft(value, count);
}
</code></pre>
<p>The <code>ShiftLeftOperator&lt;T, TResult&gt;</code> operator is non-vectorizable, as indicated by the <code>IsVectorizable</code> property. The <code>Invoke()</code> method for <code>Vector&lt;T&gt;</code> values throws a <code>NotSupportedException</code>. Conversely, the <code>ShiftLeftSByteOperator</code> operator is vectorizable, as it doesn't include the <code>IsVectorizable</code> property, and the <code>Invoke()</code> method for <code>Vector&lt;sbyte&gt;</code> values is implemented.</p>
<p>For an operation akin to <code>ShiftLeft</code>, which offers implementations for specific types, the library provides all the following operations. The compiler will automatically select the suitable overload based on the type in use:</p>
<pre><code class="lang-csharp">public static void ShiftLeft&lt;T&gt;(ReadOnlySpan&lt;T&gt; value, int count, Span&lt;T&gt; destination)
    where T : struct, IShiftOperators&lt;T, int, T&gt;
    =&gt; ShiftLeft&lt;T, T&gt;(value, count, destination);

public static void ShiftLeft&lt;T, TResult&gt;(ReadOnlySpan&lt;T&gt; value, int count, Span&lt;TResult&gt; destination)
    where T : struct, IShiftOperators&lt;T, int, TResult&gt;
    where TResult : struct
    =&gt; ApplyScalar&lt;T, int, TResult, ShiftLeftOperator&lt;T, TResult&gt;&gt;(value, count, destination);

public static void ShiftLeft(ReadOnlySpan&lt;sbyte&gt; value, int count, Span&lt;sbyte&gt; destination)
    =&gt; ApplyScalar&lt;sbyte, int, sbyte, ShiftLeftSByteOperator&gt;(value, count, destination);
</code></pre>
<p>For brevity, only the overload for the <code>sbyte</code> type is presented here.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/NetFabric/NetFabric.Numerics.Tensors/blob/main/docs/articles/Extending-the-library.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (c) 2023-2024 Antão Almada
        </div>
      </div>
    </footer>
  </body>
</html>
